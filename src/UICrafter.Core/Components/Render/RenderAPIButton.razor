@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.WebUtilities
@using System.Collections.Concurrent
@inherits BaseAPIButton
@inject IHttpClientProvider HttpClientProvider
@inject ISnackbar Snackbar

@{
    base.BuildRenderTree(__builder);
}

@code {
    [Parameter]
    public required UIComponent Button { get; set; }

    [CascadingParameter]
    public required JsonPublisher JSONPublisher { get; set; }

    [CascadingParameter]
    public required ConcurrentDictionary<string, BaseInput> LogicalNamesPairing { get; set; }

    private string ModifiedURL { get; set; } = string.Empty;

    private bool _processing = false;

    protected override void OnInitialized()
    {
        ButtonText = Button.Button.Label;
        OnClick = EventCallback.Factory.Create<MouseEventArgs>(this, ExecuteApiCall);
    }

    private async Task ExecuteApiCall()
    {
        if (_processing) return;

        _processing = true;

        if (string.IsNullOrEmpty(Button.Button.URL))
        {
            NotifyUser(Color.Info, "Button URL is empty", Severity.Info);
            _processing = false;
            return;
        }

        ModifiedURL = ReplaceLogicalNames(Button.Button.URL);

        try
        {
            Log.Information(ModifiedURL);
            var response = await ExecuteHttpRequest(Button.Button.HttpMethod, ModifiedURL, Button.Button.HttpHeaders, Button.Button.HttpBody);

            await HandleApiResponse(response);
        }
        catch (Exception ex)
        {
            Log.Error("Something went wrong fetching from endpoint {exception}", ex);
            NotifyUser(Color.Error, ex.Message, Severity.Error);
        }
        finally
        {
            _processing = false;
        }
    }

    private void NotifyUser(Color buttonColor, string message, Severity severity)
    {
        ButtonColor = buttonColor;
        Snackbar.Add(message, severity);
    }

    private string ReplaceLogicalNames(string s)
    {
        foreach (var pair in LogicalNamesPairing)
        {
            s = s.Replace($"{{{pair.Key}}}", pair.Value.GetValue());
        }

        return s;
    }

    private async Task<HttpResponseMessage> ExecuteHttpRequest(CallMethod httpMethod, string url, RepeatedField<HttpHeader> headers, string body)
    {
        var httpClient = HttpClientProvider.GetDefaultHttpClient();

        var method = httpMethod switch
        {
            CallMethod.Get => HttpMethod.Get,
            CallMethod.Post => HttpMethod.Post,
            CallMethod.Put => HttpMethod.Put,
            CallMethod.Delete => HttpMethod.Delete,
            _ => throw new InvalidOperationException($"Unsupported HTTP method: {httpMethod}")
        };

        using var request = new HttpRequestMessage(method, url);

        foreach (var header in headers)
        {
            request.Headers.Add(header.Key, header.Value);
        }

        body = ReplaceLogicalNames(body);

        request.Content = new StringContent(body);

        return await httpClient.SendAsync(request);
    }

    private async Task HandleApiResponse(HttpResponseMessage response)
    {
        var responseData = await response.Content.ReadAsStringAsync();

        if (response.IsSuccessStatusCode)
        {
            NotifyUser(Color.Success, "Success", Severity.Success);
            JSONPublisher.NotifySubscribers(Button.Guid, responseData);
        }
        else
        {
            Log.Debug("Bad response from appview API: {ErrorMessage}", responseData);

            NotifyUser(Color.Error, $"{(int)response.StatusCode} - {response.StatusCode}", Severity.Error);

            var jsonResponse = JsonSerializer.Serialize(new { StatusCode = $"{(int)response.StatusCode} - {response.ReasonPhrase}", Data = responseData });
            JSONPublisher.NotifySubscribers(Button.Guid, jsonResponse);
        }

        Log.Information("Response status code: {StatusCode}", (int)response.StatusCode);
    }
}

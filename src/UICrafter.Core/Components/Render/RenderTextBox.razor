@using System.Text.Json
@using System.Text;
@inherits BaseTextBox

@{
    base.BuildRenderTree(__builder);
}

@code {
    [Parameter]
    public required UIComponent Textbox { get; set; }

    [CascadingParameter]
    public required JsonPublisher JSONPublisher { get; set; }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        Label = Textbox.Textbox.Label;
        Content = Textbox.Textbox.Content;
        Lines = Textbox.Textbox.NumberOfLines;


        if (!string.IsNullOrEmpty(Textbox.Textbox.SourceRef))
        {
            JSONPublisher.Subscribe(Textbox.Textbox.SourceRef, UpdateTextboxContent);
        }
    }
    //old update
    // private void UpdateTextboxContent(Dictionary<string, object> jsonResponse)
    // {
    //     if (string.IsNullOrEmpty(Textbox.Textbox.JsonField))
    //     {
    //         Content = "No JsonField specified.";
    //     }
    //     else
    //     {

    //         if (Textbox.Textbox.JsonField == "response")
    //         {
    //             List<string> values = ExtractValues(jsonResponse);

    //             string description = string.Join(" ", values);

    //             Content = description;
    //             StateHasChanged();
    //             return;
    //         }
    //         else
    //         {
    //             string fieldName = Textbox.Textbox.JsonField;

    //             if (jsonResponse.TryGetValue(fieldName, out var fieldValue))
    //             {
    //                 string description = ConvertValueToString(fieldValue);

    //                 Content = description;
    //             }
    //             else
    //             {
    //                 Content = $"Field '{fieldName}' not found in JSON response.";
    //             }
    //         }
    //     }

    //     InvokeAsync(StateHasChanged);
    // }

    public void Dispose()
    {
        JSONPublisher?.Unsubscribe(Textbox.Textbox.SourceRef, UpdateTextboxContent);
    }
    //old json
    // private string ConvertValueToString(object value)
    // {
    //     if (value is List<object> list)
    //     {
    //         return string.Join("\n\n", list.Select(item => item.ToString()));
    //     }
    //     else if (value is Dictionary<string, object> dict)
    //     {
    //         return JsonSerializer.Serialize(dict);
    //     }
    //     else
    //     {
    //         return value?.ToString() ?? string.Empty;
    //     }
    // }

    // private List<string> ExtractValues(object obj, string parentName = "", int indentLevel = 0, bool isArrayItem = false)
    // {
    //     List<string> values = new List<string>();
    //     string indent = new string(' ', indentLevel * 2);

    //     if (obj is Dictionary<string, object> dict)
    //     {
    //         foreach (var kvp in dict)
    //         {
    //             values.AddRange(ExtractValues(kvp.Value, kvp.Key, indentLevel));
    //         }
    //     }
    //     else if (obj is List<object> list)
    //     {
    //         if (!string.IsNullOrEmpty(parentName) && !isArrayItem)
    //         {
    //             values.Add($"{indent}{parentName}:");
    //         }

    //         for (int i = 0; i < list.Count; i++)
    //         {
    //             var item = list[i];

    //             values.AddRange(ExtractValues(item, $"{parentName}[{i}]", indentLevel + 1, isArrayItem: true));
    //         }
    //     }
    //     else if (obj != null)
    //     {

    //         if (!string.IsNullOrEmpty(parentName) && !isArrayItem)
    //         {
    //             values.Add($"{indent}{parentName}: {obj}");
    //         }
    //         else
    //         {
    //             values.Add($"{indent}- {obj}");
    //         }
    //     }

    //     return values;
    // }

    // //better josn stuff try out
    // private string ConvertValueToString(object value)
    // {
    //     if (value is List<object> list)
    //     {
    //         return string.Join("\n\n", list.Select(item => ObjectAsString(item)));
    //     }
    //     else if (value is Dictionary<string, object> dict)
    //     {
    //         return string.Join("\n", dict.Select(kv => $"\"{kv.Key}\": {ObjectAsString(kv.Value)}"));
    //     }
    //     else
    //     {
    //         return value?.ToString() ?? string.Empty;
    //     }
    // }

    // private string ObjectAsString(object valueObject)
    // {
    //     if (valueObject is Dictionary<string, object> dict)
    //     {
    //         // Convert dictionary to a string format
    //         return string.Join("\n", dict.Select(kv => $"\"{kv.Key}\": {ObjectAsString(kv.Value)}")) + "\n";
    //     }
    //     else if (valueObject is List<object> list)
    //     {
    //         // Convert list to a string format
    //         return string.Join("\n", list.Select(item => ObjectAsString(item)));
    //     }
    //     else
    //     {
    //         // Direct value (e.g., string, number)
    //         return valueObject?.ToString() ?? "null";
    //     }
    // }

    // private void UpdateTextboxContent(Dictionary<string, object> jsonResponse)
    // {
    //     if (string.IsNullOrEmpty(Textbox.Textbox.JsonField))
    //     {
    //         Content = "No JsonField specified.";
    //     }
    //     else
    //     {
    //         if (Textbox.Textbox.JsonField == "response")
    //         {
    //             List<string> values = ExtractValues(jsonResponse);
    //             string description = string.Join(" ", values);
    //             Content = description;
    //             StateHasChanged();
    //             return;
    //         }
    //         else
    //         {
    //             string fieldName = Textbox.Textbox.JsonField;

    //             if (jsonResponse.TryGetValue(fieldName, out var fieldValue))
    //             {
    //                 // Convert the field value to a string format using ObjectAsString for readability
    //                 string description = ObjectAsString(fieldValue);
    //                 Content = description;
    //             }
    //             else
    //             {
    //                 Content = $"Field '{fieldName}' not found in JSON response.";
    //             }
    //         }
    //     }

    //     InvokeAsync(StateHasChanged);
    // }



    // moew chatcode try out
    // private string ConvertValueToString(object value)
    // {
    //     if (value is List<object> list)
    //     {
    //         return string.Join("\n\n", list.Select(item => ObjectAsString(item)));
    //     }
    //     else if (value is Dictionary<string, object> dict)
    //     {
    //         return string.Join("\n", dict.Select(kv => $"\"{kv.Key}\": {ObjectAsString(kv.Value)}"));
    //     }
    //     else
    //     {
    //         return value?.ToString() ?? string.Empty;
    //     }
    // }

    private string ObjectAsString(object valueObject)
    {
        if (valueObject is Dictionary<string, object> dict)
        {
            // Convert dictionary to a string format
            return string.Join("\n\n", dict.Select(kv => $"\"{kv.Key}\": {ObjectAsString(kv.Value)}"));
        }
        else if (valueObject is List<object> list)
        {
            // Convert list to a string format
            return string.Join("\n\n", list.Select(item => ObjectAsString(item)));
        }
        else
        {
            // Direct value (e.g., string, number)
            return valueObject?.ToString() ?? "null";
        }
    }

    private void UpdateTextboxContent(Dictionary<string, object> jsonResponse)
    {
        if (string.IsNullOrEmpty(Textbox.Textbox.JsonField))
        {
            Content = "No JsonField specified.";
        }
        else
        {
            // Split JsonField in case it has multiple levels (like "jokes.flags")
            string[] fieldPath = Textbox.Textbox.JsonField.Split('.');

            // Retrieve the nested field value based on the path
            if (TryGetNestedFieldValue(jsonResponse, fieldPath, out var fieldValue))
            {
                string description = ObjectAsString(fieldValue);
                Content = CleanUpString(description);
                //Content = description;
            }
            else
            {
                Content = $"Field '{Textbox.Textbox.JsonField}' not found in JSON response.";
            }
        }

        InvokeAsync(StateHasChanged);
    }

    private bool TryGetNestedFieldValue(object current, string[] fieldPath, out object result)
    {
        result = current;

        foreach (var field in fieldPath)
        {
            if (result is Dictionary<string, object> dict && dict.TryGetValue(field, out var tempResult))
            {
                result = tempResult;
            }
            else if (result is List<object> list && int.TryParse(field, out int index) && index < list.Count)
            {
                result = list[index];
            }
            else
            {
                result = null;
                return false;
            }
        }

        return true;
    }

    // private List<string> ExtractValues(object obj, string parentName = "")
    // {
    //     List<string> values = new List<string>();

    //     if (obj is Dictionary<string, object> dict)
    //     {
    //         foreach (var kvp in dict)
    //         {
    //             values.AddRange(ExtractValues(kvp.Value, kvp.Key));
    //         }
    //     }
    //     else if (obj is List<object> list)
    //     {
    //         // Flatten list values and concatenate them into a single string
    //         string listContent = string.Join(", ", list.Select(item => item.ToString()));
    //         values.Add($"{parentName}: {listContent}");
    //     }
    //     else if (obj != null)
    //     {
    //         // Add key-value pair in a single line without indentation
    //         values.Add($"{parentName}: {obj}");
    //     }

    //     return values;
    // }

    public string CleanUpString(string input)
    {
        // Characters to be removed
        //char[] charsToRemove = { '\"', '\'', '{', '}', '[', ']', '(', ')' };
        char[] charsToRemove = { '\"', '\'' };
        System.Text.StringBuilder cleanedString = new StringBuilder();

        foreach (char c in input)
        {
            // Only append characters that are not in charsToRemove
            if (!charsToRemove.Contains(c))
            {
                cleanedString.Append(c);
            }
        }

        return cleanedString.ToString();
    }

}
